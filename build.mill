package build

import mill._, scalalib._

object core extends ScalaModule  {

  def scalaVersion = "3.7.0"
  
  def ivyDeps = Agg(
    ivy"org.graalvm.polyglot:polyglot:24.2.1",
    ivy"org.graalvm.polyglot:js:24.2.1",
    ivy"org.graalvm.polyglot:wasm:24.2.1",
    ivy"com.vladsch.flexmark:flexmark-all:0.64.8"
  )
}

object flatmark extends ScalaModule with CustomJpackageModule {

  def scalaVersion = "3.7.0"
  
  def moduleDeps = Seq(core)
  
  // samo za windows zasad
  def jpackageType = "msi"
}

import mill.util.Jvm
trait CustomJpackageModule extends JpackageModule {
    def jpackageAppImage2: T[PathRef] = Task {
    // materialize all jars into a "lib" dir
    val libs = Task.dest / "lib"
    val cp = jpackageRunClasspath().map(_.path)
    val jars = cp.filter(os.exists).zipWithIndex.map { case (p, idx) =>
      val dest = libs / s"${idx + 1}-${p.last}"
      os.copy(p, dest, createFolders = true)
      dest
    }

    val appName = jpackageName()
    val appType = jpackageType()
    val mainClass = jpackageMainClass()
    val mainJarName = jars.head.last

    val args: Seq[String] = Seq(
      Jvm.jdkTool("jpackage", this.jvmWorker().javaHome().map(_.path)),
      "--type",
      appType,
      "--name",
      appName,
      "--input",
      libs.toString(),
      "--main-jar",
      mainJarName,
      "--main-class",
      mainClass,
      "--win-console"
    )

    // run jpackage tool
    val outDest = Task.dest / "image"
    os.makeDir.all(outDest)
    os.proc(args).call(cwd = outDest)
    PathRef(outDest)
  }
}